#title# SOLID principles explained as lego bricks
#meta# Framing abstract concepts in a familiar way
#created# 2022-07-10
#tags# C#
#image# lego-bricks.png

#tldr#

<p>If you follow the SOLID principles the different parts of your code should be understandable and interchangeable, much like lego bricks.</p>

#heading# Getting our priorities straight

<p>It is said that 80% of the cost of a system happens after the system is launched. Reasons for this could be new features, changes, operations, and bugs.</p>

<p>The implications are huge - <b>your code-writing speed is not important</b>. What is important is how easily existing code can be:</p>
<ul>
    <li>Understood</li>
    <li>Modified</li>
    <li>Re-used</li>
</ul>

#heading# Principles

<p>To guide us when making decisions on <b>how</b> to write code, we use principles. Juxtaposing different principles against each other helps us to understand the tradeoffs between different decisions.</p>

<p>The SOLID principles are well established in the OOP-community, and they consist of the:</p>
<ul>
    <li><b>S</b>ingle responsibility principle</li>
    <li><b>O</b>pen/closed principle</li>
    <li><b>L</b>iskov substitution principle</li>
    <li><b>I</b>nterface segregation principle</li>
    <li><b>D</b>ependency inversion principle</li>
</ul>

#heading# The Single Responsibility Principle

<p>Let's imagine we are trying to build an ice-cream program. Exactly what it does is not important, but it will need some logging, business logic, database connectivity and stream reading:</p>

<div style="text-align: center; margin-top: 50px; margin-bottom:50px;">
    <img src="lego-solid-program.png" style="max-width: 100%" />
</div>

<p>Now, the yellow piece expects to be connected to the stream-reader. Let's define the interface (i.e. the "dots" of the yellow lego piece):</p>

<code><pre class="prettyprint lang-csharp">
public interface IIceCreamStreamReader {
	IceCreamData[] ReadFromStream(string fileName)
}
</pre></code>

<p><b>INSERT IMAGE OF MISSING PART</b></p>

<p>So, we'll try to implement the stream reading part:</p>

<code><pre class="prettyprint lang-csharp">
public class IceCreamStreamReader {
    public IceCreamData[] ReadFromStream(string fileName) {
		var executablePath = Assembly.GetEntryAssembly().Location;
		var filePath = Path.Combine(fileName, executablePath)
		var stream = File.OpenRead(filePath)

		IceCreamData[] iceCreams = new IceCreamData[] {};

		var array = new byte[300];
		var span = new Span<byte>(array);
		while(stream.Read(span,0,span.length) > 0) {
			iceCreams.push(ParseAsIceCream(span));
		}

		foreach(var iceCream in iceCreams) {
		  if (iceCream.Size > 5 || iceCream.Size < 1) {
		    throw new Exception("Invalid ice cream size");
		  }
		  if (!PossibleTastes.Contains(iceCream.Taste)) {
		    throw new Exception("Unknown taste");
		  }
		  if (iceCream.Payment != 0) {
		  	throw new Exception("Ice cream payment should be 0")
		  }
		}
	}

    private IceCreamData ParseAsIceCream(Span<byte> span) {
        // A b*ttload of parsing code
        // ...
    }
}
</pre></code>


